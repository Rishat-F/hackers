# Шпаргалка по терминалу Линукса

КОМАНДЫ ТЕРМИНАЛА LINUX
a2p - конвертировать awk скрипт в программу на perl;
ac - вывести статистику по времени работы пользователя в системе;
addgroup - добавить новую группу в систему;
adduser - добавить нового пользователя;
agrep - версия утилиты grep, которая может обрабатывать усредненные паттерны;
alias - создание псевдонимов для команды консоли linux;
apropos - поиск по ключевому слову или регулярному выражению в страницах справки man;
apt - поиск, установка и удаление программ в Ubuntu;
aptitude - текстовая оболочка для apt, позволяет управлять программным обеспечением, используется по умолчанию в Debian;
ar - утилита для создания, модификации и извлечения файлов из архивов ar;
arch - отображает информацию об архитектуре системы;
arp - управление таблицей ARP кэша;
as - ассемблер;
aspell - интерактивная проверка орфографии;
at - запланировать запуск команды на нужное время;
awk - утилита для фильтрации текста на основе регулярных выражений и языка программирования AWK;
basename - удаляет информацию о директории из имени файла;
bash - интерпретатор команд Bourne Again Shell, используется по умолчанию в большинстве дистрибутивов Linux;
bс - простой консольный калькулятор;
bdiff - поиск отличий в больших файлах;
bfs - текстовый редактор, для работы с большими файлами;
bg - восстановить задачу, свернутую в фоновый режим;
biff - получить подробную информацию про электронное письмо в терминале;
break - завершить цикл while, for, foreach или until;
bs - версия игры Battleship для Linux;
bye - эквивалент команды exit, используется для выхода из терминала;
cal - отобразить правильно отформатированный календарь в командной строке;
calendar - отобразить напоминания и заметки;
cancel - остановить вывод информации о работе задачи;
cat - вывести содержимое файла;
cc - компилятор языка Си;
cd - изменить рабочую директорию;
cfdisk - утилита для разметки диска в терминале, более простая в использовании, чем fdisk;
chdir - аналог cd, меняет текущую директорию на указанную;
checkeq - процессор языка программирования для описания сравнений;
checknr - проверка файлов nroff и troff на ошибки;
chfn - изменить дополнительную информацию о пользователе, такую как номер телефона, имя и так далее;
chgrp - изменить группу для файла;
chmod - изменить разрешения для файлов или папок;
chown - изменить владельца файла;
chroot - запустить команду или оболочку в другом корневом каталоге, каталог изолирован и команда не может получить из него доступ к внешней системе;
chsh - изменить оболочку входа;
cksum - подсчитать и вывести CRC сумму для файла;
clear - очистить вывод терминала;
cmp - сравнить два файла побайтно;
col - команда читает стандартный ввод построчно и передает информацию на вывод с возможностью реверсной подачи бумаги;
comm - сравнить два небольших файла построчно;
compress - сжать один или несколько файлов;
continue - завершить текущую итерацию while, for, foreach и until;
cp - скопировать файл или папку;
cpio - создание и распаковка архивов типа cpio;
crontab - настройка расписаний и заданий планировщика cron;
csh - командная оболочка C Shell;
csplit - обрезать часть файла по шаблону;
ctags - создать файл тегов для исходного кода;
cu - отправка сигнала другой системе через терминал;
curl - передача и получение данных с удаленного сервера;
cut - обрезать определенную часть каждой строки из файла;
date - отобразить текущую дату и время;
dc - сложный стековый арифметический калькулятор;
dd - утилита для копирования бинарных данных из одного места в другое;
delgroup - удалить группу;
deluser - удалить пользователя;
depmod - вывести список всех загруженных модулей ядра и их зависимостей;
deroff - удалить nroff, troff конструкции из файлов;
df - посмотреть общее доступное дисковое пространство в системе;
dhclient - получить динамический ip адрес по DHCP;
dig - посмотреть информацию о DNS;
dircmp - сравнение содержимого двух папок;
dirname - удалить имя файла из адреса, оставить только адрес папки;
dmesg - вывести последние записи журнала ядра;
dos2unix - конвертировать текстовые файлы из формата DOS в Unix;
dpkg - низкоуровневая утилита установки пакетов в Ubuntu;
dpost - перекодирование файлов из формата troff в PostScript;
du - отобразить занимаемое каждым файлом место на диске;
echo - вывести строку текста;
ed - простой текстовый редактор;
edit - еще один текстовый редактор;
egrep - фильтрация текста с учетом регулярных выражений;
eject - извлечь лоток CD-ROM;
elm - клиент электронной почты;
emacs - очень мощный и настраиваемый текстовый редактор;
emerge - пакетный менеджер Gentoo;
enable - включение и отключение принтеров LP;
env - вывести значение переменной окружения;
eqn - язык программирования для описания сравнений;
ex - режим редактирования строки редактора Vim;
exit - завершить сеанс работы с оболочкой;
expand - заменить символы табуляции на ряд пробелов;
expr - обработать аргументы как выражение;
fc - вывод, модификация и выполнение  команд из истории;
fdisk - утилита для разметки диска;
fg - восстановление программы, свернутой в фоновый режим;
fgrep - фильтрация текста только по целым строкам;
file - вывод типа файла;
find - поиск файлов в файловой системе по разным условиям;
findsmb - вывести список всех машин, доступных по протоколу SMB;
finger - вывести дополнительную информацию о пользователе;
fmt - форматирование и оптимизация текстовых файлов;
fold - позволяет переносить строки указанной дины из одного файла в другой;
for - организация цикла со счетчиком для выполнения нескольких команд;
foreach - выполнять набор команд для каждого из элементов переданного массива;
free - отобразить свободную оперативную память;
fsck - проверка файловой системы на ошибки;
ftp - интерактивная команда для доступа к FTP серверу;
fuser - позволяет определить какой процесс использует файлы или сокеты;
gawk - GNU версия утилиты awk;
gcc - компилятор языка программирования C++;
getfacl - отобразить информацию про списки контроля доступа для файла;
gpasswd - управление файлами /etc/group и /etc/passwd;
gprof - отобразить доступную информацию о профилировании программы;
grep - фильтрация текста на основе регулярных выражений;
groupadd - создать новую группу;
groupdel - удалить группу;
groupmod - изменение группы;
gnuzip - распаковка сжатых файлов;
gview - запускает графическую версию реактора Vim;
gvim - синоним для gview;
gzip - создание, изменение, просмотр содержимого и распаковка архивов Gzip;
halt - немедленно выключить компьютер;
head - отобразить первые 10 строк из файла;
help - вывести помощь по командной оболочке;
history - вывести последние использованные команды linux;
host - преобразовать имя хоста в ip адрес;
hostid - вывести цифровой идентификатор для хоста;
hostname - вывод и настройка текущего имени хоста;
htop - интерактивный диспетчер задач, который работает в терминале;
id - вывести информацию о пользователей и его группах;
ifconfig - вывод и настройка сетевых интерфейсов;
ifdown - отключить сетевой интерфейс;
ifquery - выбрать информацию о сетевом интерфейсе;
ifup - включить сетевой интерфейс;
info - просмотр документации;
insmod - загрузить модуль ядра, в параметрах нужно передать файл;
iostat - статистика нагрузки на процессор и жесткие диски;
ip - новая утилита для управления сетевыми интерфейсами;
iwconfig - настройка беспроводных сетевых интерфейсов;
jobs - вывести список и состояние всех, запущенных в фоне задач;
join - объединить строки из двух файлов;
kill - отправить сигнал процессу, например, чтобы его завершить;
lillall - убить все процессы с указанным именем;
ksh - командная оболочка Korn Shell;
last - отобразить историю входов пользователей;
ld - редактор ссылок на библиотеки для объектов;
ldd - выводит список зависимостей исполняемого файла и статических объектов;
less - постраничная прокрутка длинного текста;
link - создать жесткую ссылку на файл;
ln - создать символическую ссылку на файл;
lo - завершить работу с командной оболочкой;
locate - поиск файлов, используя проиндексированную базу данных;
login - войти в систему;
logname - выводит логин пользователя;
logout - аналог lo;
losetup - создание и управление виртуальными loop устройствами;
ls - вывести содержимое каталога;
lsmod - посмотреть все загруженные модули ядра;
lsof - посмотреть список всех открытых файлов;
lzcat - посмотреть содержимое файла, сжатого lzma;
lzma - сжать или распаковать файл по алгоритму lzma;
mach - вывести информацию о процессоре;
mailx - обработать сообщения электронной почты;
make - выполнить сборку программы из исходников;
man - просмотр документации;
merge - объединить содержимое трех файлов в один;
mesg - отправка сообщений в другой терминал;
mkdir - создать папку linux;
mkfs - форматировать раздел в выбранную файловую систему;
mkswap - форматировать раздел или файл в swap;
modinfo - вывести информацию про модуль ядра;
modprobe - загрузить модуль ядра по имени;
more - еще одна команда для прокрутки длинного текста;
mount - монтирование разделов;
mt - управление магнитными кассетами;
mv - перемещение файлов и каталогов;
mysql - утилита для управления реляционной базой данных MySQL;
mysqldump - утилита для создания резервной копии базы данных MySQL;
nc - инструмент для передачи данных по TCP/IP;
netstat - вывод информации про сетевые соединения, таблицы маршрутизации, статистику интерфейсов и другое;
newgrp - дать пользователю права новой группы на время;
nice - настройка приоритета для команды;
niscat - отобразить все таблицы NIS и объекты;
nischmod - изменить права для объекта NIS;
nischown - изменить владельца объекта NIS;
nischttl - изменить время жизни пакетов для NIS:
nisdefaults - отобразить параметры по умолчанию для NIS;
nistbladm - администрирование таблиц NIS;
nl - вывод количества строк в файле;
nmap - сетевой сканер открытых портов и уязвимостей;
nohup - продолжить выполнение команды, когда сессия терминала будет завершена;
nroff - форматировать документ для отправки на принтер;
nslookup - получить информацию DNS об удаленном сервере;
od - вывести содержимое файла в двоичном формате;
on - выполнить команду в удаленной системе, но с локальными переменными среды;
onintr - вывести информацию об аппаратных прерываниях;
pack - сжатие файлов по алгоритму Хафмана;
pacman - пакетный менеджер ArchLinux;
pagesize - отобразить размер страниц памяти в байтах;
parted - утилита для разметки диска;
partprobe - проинформировать операционную систему про изменения в таблице разделов;
passwd - изменить пароль пользователя;
paste - объединить строки из файлов;
pax - управление архивами pax;
pact - вывести содержимое сжатого текстового файла;
perl - интерпретатор скриптов Perl;
pg - вывод текстового файла постранично;
pico - простой текстовый редактор;
pine - утилита для просмотра почты;
pkill - убить процесс по его имени, только один;
poweroff - выключить компьютер;
pr - подготовить текст к печати;
printenv - вывести все переменные среды;
printf - вывести отформатированную строку текста;
ps - вывести список запущенных процессов;
pstree - вывести список запущенных процессов в виде дерева;
pvs - вывести версию и внутреннюю информацию из файла ELF;
pwd - показать текущую папку;
quit - завершить сеанс командной оболочки;
rcp - скопировать файл в удаленную систему;
readlink - вывести содержимое символической ссылки;
reboot - перезагрузка компьютера;
red - запустить ed в режиме прокрутки текста;
rename - переименовать несколько файлов в Linux;
repeat - повторять выполнение команды нужное количество раз;
replace - утилита для замены содержимого в строках;
rlogin - войти в удаленную систему;
rm - удалить файл;
rmdir - удалить папку;
rmmod - выгрузить модуль ядра;
route - отобразить таблицу маршрутизации;
rpcinfo - вывести информацию о RPC;
rsh - выполнить команду в удаленной системе;
rsync - быстрый инструмент для копирования и синхронизации файлов с удаленной системой;
s2p - конвертировать sed скрипт в Perl;
scp - копирование файлов по ssh;
screen - консольный менеджер виртуальных терминалов;
script - записывает все, что выводится на экран;
sdiff - сравнивает два файла;
sed - потоковый редактор текста на основе регулярных выражений;
sendmail - отправить письмо;
service - управление службами в Ubuntu;
set - установить значение переменной окружения;
setfacl - настройка списков контроля доступа для файлов;
sfdisk - еще одна программа для разметки дисков;
sftp - клиент для работы с sFTP по защищенному каналу;
sh - командная оболочка Bourne Shell;
shred - удалить файл без возможности восстановления;
shutdown - выключить компьютер или спланировать выключение;
sleep - ожидать указанное количество секунд;
slogin - войти в удаленную систему;
smbclient - консольный клиент для работы с удаленной системой по протоколу SMB;
sort - сортировка строк в Linux;
spell - проверка орфографии;
split - объединение файлов;
startx - запустить сессию X сервера;
ss - просмотр информации о сетевых подключениях;
ssh - подключение к удаленной системе;
stat - отобразить статистику для файла или файловой системы;
stop - остановить задачу в фоне;
strftime - форматировать строку с датой и временем;
strip - удалить отладочную информацию из исполняемых файлов;
stty - настройка параметров текущего терминала;
su - авторизация от имени другого пользователя;
sudo - выполнить команду от имени другого пользователя;
swapoff - отключить раздел подкачки;
swapon - включить раздел подкачки;
systemctl - управление службами в systemd;
tabs - остановить работу вкладок в терминале;
tac - вывести тест, полученный на входе в обратном порядке;
tail - отобразить последних 10 строк файла;
talk - отправить сообщение другому, авторизованному пользователю;
tar - упаковка и распаковка архивов tar;
tcopy - копирование магнитных кассет;
tcpdump - консольный сетевой анализатор;
tcsh - командная оболочка tcsh;
tee - вывести поток ввода в несколько источников;
telnet - утилита для подключения к удаленному порту компьютера;
test - проверка типа файла;
time - замер времени работы команды консоли linux;
timex - замер времени работы команды с выводом более подробной информации;
todos - конвертирование текстовых файлов Unix в формат DOS;
top - интерактивный консольный менеджер процессов для Linux;
touch - создать файл;
traceroute - просмотр маршрута до удаленного узла;
tree - отобразить содержимое файла в формате дерева;
tty - вывести имя файла текущего терминала;
umask - установить маску прав для создания файлов;
umount - размонтировать раздел;
unalias - удалить псевдоним;
uname - посмотреть информацию о системе и ядре;
uncompress - распаковать сжатый файл;
uniq - найти количество уникальных строк в файле;
unlink - удалить ссылку на файл;
unlzma - распаковать архив lzma;
unpack - извлечь файлы из архива pack;
until - организация цикла типа until;
unxz - извлечь все файлы из архива xz;
unzip - распаковать zip архив;
uptime - узнать время работы компьютера;
useradd - добавить пользователя;
userdel - удалить пользователя;
usermod - настройка пользователя;
vacation - настройка автоматических ответов на email;
vi - текстовый редактор Vi;
vim - аналог vi;
w - посмотреть авторизованных на данный момент пользователей;
wait - ожидает завершения процесса;
wall - отправляет сообщение всем авторизованным пользователям;
watch - выполнять указанную команду каждые n секунд, по умолчанию 1 секунда;
wc - подсчет количества строк;
wget - загрузка файлов из удаленного сервера;
whereis - просмотр адреса исполняемого файла, исходников и страниц справки для команды;
which - просмотр пути исполняемого файла для команды;
while - организация цикла типа while;
who - посмотреть активных пользователей в системе;
whoami - вывести текущего пользователя;
whois - вывести доступную информацию об интернет ресурсе;
Xorg - исполняемый файл X сервера;
xargs - позволяет составлять команды на лету;
xfd - отобразить все символы шрифта X сервера;
xhost - настройка прав доступа к X серверу;
xlsfonts - отобразить все шрифты X сервера;
xrdb - управление базой данных ресурсов X сервера;
xset - изменить значение переменной X сервера;
xz - сжать файл в формат xz;
xzcat - посмотреть содержимое текстового файла сжатого xz;
yacc - компилятор Yet another compiler-compiler;
yes - ответить да, на запрос другой команды;
yppasswd - изменить пароль базы данных NIS;
yum - пакетный менеджер дистрибутивов Red Hat;
zcat - вывести содержимое файла, сжатого zip;
zipcloack - зашифровать zip файл;
zipinfo - вывести информацию о zip файле;
zipnote - просмотр и изменение комментариев к zip файлам;
zipsplit - объединение нескольких zip файлов;
zypper - менеджер пакетов OpenSUSE.


КОМАНДЫ LINUX ДЛЯ УПРАВЛЕНИЯ ФАЙЛАМИ
1. LS
Утилита для просмотра содержимого каталогов. По умолчанию показывает текущий каталог. Если в параметрах указать путь, то она перечислит содержимое конечного каталога. Полезные опции -l (List) и -a (All). Первая форматирует вывод в виде списка с более подробной информацией, а вторая включает показ скрытых файлов. 
	$ ls опции /путь/к/папке

	Опции команды указывают как именно и в каком виде нужно выводить информацию на экран, а путь, это та папка, которую нужно отобразить. Рассмотрим основные опции утилиты:

	-a - отображать все файлы, включая скрытые, это те, перед именем которых стоит точка;
	-A - не отображать ссылку на текущую папку и корневую папку . и ..;
	--author - выводить создателя файла в режиме подробного списка;
	-b - выводить Escape последовательности вместо непечатаемых символов;
	--block-size - выводить размер каталога или файла в определенной единице измерения, например, мегабайтах, гигабайтах или килобайтах;
	-B - не выводить резервные копии, их имена начинаются с ~;
	-c - сортировать файлы по времени модификации или создания, сначала будут выведены новые файлы;
	-C - выводить колонками;
	--color - включить цветной режим вывода, автоматически активирована во многих дистрибутивах;
	-d - выводить только директории, без их содержимого, полезно при рекурсивном выводе;
	-D - использовать режим вывода, совместимый с Emacs;
	-f - не сортировать;
	-F - показывать тип объекта, к каждому объекту будет добавлен один из специализированных символов */=>@|;
	--full-time - показывать подробную информацию, плюс вся информация о времени в формате ISO;
	-g - показывать подробную информацию, но кроме владельца файла;
	--group-directories-first - сначала отображать директории, а уже потом файлы;
	-G - не выводить имена групп;
	-h - выводить размеры папок в удобном для чтения формате;
	-H - открывать символические ссылки при рекурсивном использовании;
	--hide - не отображать файлы, которые начинаются с указанного символа;
	-i - отображать номер индекса inode, в которой хранится этот файл;
	-l - выводить подробный список, в котором будет отображаться владелец, группа, дата создания, размер и другие параметры;
	-L - для символических ссылок отображать информацию о файле, на который они ссылаются;
	-m - разделять элементы списка запятой;
	-n - выводить UID и GID вместо имени и группы пользователя;
	-N - выводить имена как есть, не обрабатывать контролирующие последовательности;
	-Q - брать имена папок и файлов в кавычки;
	-r - обратный порядок сортировки;
	-R - рекурсивно отображать содержимое поддиректорий;
	-s - выводить размер файла в блоках;
	-S - сортировать по размеру, сначала большие;
	-t - сортировать по времени последней модификации;
	-u - сортировать по времени последнего доступа;
	-U - не сортировать;
	-X - сортировать по алфавиту;
	-Z - отображать информацию о расширениях SELinux;
	-1 - отображать один файл на одну строку.


2. CAT
Печатает содержимое файла, переданного в параметре, в стандартный вывод. Если передать несколько файлов, команда склеит их. Также можно перенаправить вывод в ещё один файл с помощью символа '>'. Если нужно вывести только определенное количество строк, используйте опцию -n (Number).
	$ cat опции файл1 файл2 ...

	Вы можете передать утилите несколько файлов и тогда их содержимое будет выведено поочередно, без разделителей. Опции позволяют очень сильно видоизменить вывод и сделать именно то, что вам нужно. Рассмотрим основные опции:

	-b - нумеровать только непустые строки;
	-E - показывать символ $ в конце каждой строки;
	-n - нумеровать все строки;
	-s - удалять пустые повторяющиеся строки;
	-T - отображать табуляции в виде ^I;
	-h - отобразить справку;
	-v - версия утилиты.

3. CD
Позволяет перейти из текущего каталога в указанный. Если запустить без параметров - возвращает в домашний каталог. Вызов с двумя точками возвращает на уровень вверх относительно текущего каталога. Вызов с тире (cd -) возвращает к предыдущему каталогу. 
	$ cd опции папка_назначения

	Опций всего две, это -P и -L. Они влияют на то, как будут обрабатываться символы возврата в предыдущую директорию и символические ссылки:

	-P - позволяет следовать по символическим ссылкам перед тем, как будут обработаны все переходы "..";
	-L - переходит по символическим ссылкам только после того, как были обработаны "..";
	-e - если папку, в которую нужно перейти не удалось найти - выдает ошибку.

4. PWD
Печатает на экран текущий каталог. Это может быть полезно, если ваша командная строка Linux не выводит такую информацию. Эта команда будет востребована в Bash программировании, где для получения ссылки на каталог выполняется скрипт.
	$ pwd опции

	Вот основные опции, которые вы можете использовать для настройки вывода утилиты:

	-L, --logical - брать директорию из переменной окружения, даже если она содержит символические ссылки;
	-P - отбрасывать все символические ссылки;
	--help - отобразить справку по утилите;
	--version - отобразить версию утилиты.

5. MKDIR
Создание новых каталогов. Наиболее удобная опция -p (Parents), позволяет создать всю структуру подкаталогов одной командой, даже если они ещё не существуют.
	$ mkdir опции имя_папки

	Опций в утилиты не так много, а передавать программе вы чаще всего будете только один параметр - имя папки

	Давайте попробуем. Откройте терминал (Нажмите сочетание клавиш Ctrl+Alt+T) и наберите следующую команду:

	 $ mkdir папка

	В текущей директории будет создана папка с указанным именем. Если нужно создать папку в другой директории, перед именем укажите путь к той директории:

	 $ mkdir Загрузки/папка

	Утилита создаст папку в подпапке загрузки. Можно использовать не только путь относительно текущей папки, но и указать полный путь в файловой системе:

	 $ mkdir ~/Загрузки/папка

	 $ mkdir /home/имя_вашего_пользователя/папка

	Это собственно все основное. Но еще я хочу вам показать на что способен терминал в отличие от графических программ.

	Например, нам нужно создать несколько папок, тогда можно сделать все одной командой:

	 $ mkdir {папка1,папка2,папка3}

	Если нужно создать папку Ubuntu, а в ней еще несколько папок, можно воспользоваться командой:

	 $ mkdir -p ~/Загрузки/папка/папка/папка/папка

	Или, например, сложная структура:

	 $ mkdir -p ~/Загрузки/папка/{папка1,папка2,папка3}

6. FILE
Команда file показывает тип файла. В Linux файлы не обязаны всегда иметь расширения для того, чтобы с ними работать. Поэтому пользователю иногда трудно определить, что за файл перед ним. Эта маленькая утилита решает проблему.
	$ file опции название_документа

	Что же касается опций, то их у этой команды несколько десятков. Мы рассмотрим лишь основные:

	-b, --brief — запрет на демонстрацию имен и адресов файлов в выводе команды;
	-i, --mime — определение MIME-типа документа по его заголовку;
	--mime-type, --mime-encoding — определение конкретного элемента MIME;
	-f, --files-from — анализ документов, адреса которых указаны в простом текстовом файле;
	-l, --list — список паттернов и их длина;
	-s, --special-files — предотвращение проблем, которые могут возникнуть при чтении утилитой специальных файлов;
	-P — анализ определенной части файла, которая обозначается различными параметрами;
	-r, --raw — отказ от вывода /ooo вместо непечатных символов;
	-z — анализ содержимого сжатых документов.
	Для того, чтобы ознакомиться с полным списком опций, выполните в терминале команду:

	$ man file

7. CP
Копирование файлов и каталогов. Она не копирует каталоги по умолчанию рекурсивно (то есть все поддиректории и все файлы в поддиректориях), поэтому не забудьте добавить опцию -r (Recursive) или -a (Archive). Последняя включает режим сохранения атрибутов, владельца и временного штампа в дополнение к рекурсивному копированию.
	Общий синтаксис cp выглядит вот так:

	$ cp опции файл-источник файл-приемник

	Или:

	$ cp опции файл-источник директория-приемник/

	После выполнения команды файл-источник будет полностью перенесен в файл-приемник. Если в конце указан слэш, файл будет записан в заданную директорию с оригинальным именем.

	Утилита имеет несколько интересных опций, которые могут сильно помочь при нестандартных задачах копирования, поэтому давайте их рассмотрим:

	--attributes-only - не копировать содержимое файла, а только флаги доступа и владельца;
	-f, --force - перезаписывать существующие файлы;
	-i, --interactive - спрашивать, нужно ли перезаписывать существующие файлы;
	-L - копировать не символические ссылки, а то, на что они указывают;
	-n - не перезаписывать существующие файлы;
	-P - не следовать символическим ссылкам;
	-r - копировать папку Linux рекурсивно;
	-s - не выполнять копирование файлов в Linux, а создавать символические ссылки;
	-u - скопировать файл, только если он был изменён;
	-x - не выходить за пределы этой файловой системы;
	-p - сохранять владельца, временные метки и флаги доступа при копировании;
	-t - считать файл-приемник директорией и копировать файл-источник в эту директорию.

8. MV
Перемещение или переименование файлов и каталогов. Примечательно, что в Linux это одна и та же операция. Переименование - это перемещение файла в ту же папку с другим именем.
	$ mv опции файл-источник файл-приемник

	Теперь рассмотрим основные опции утилиты, которые могут вам понадобиться:

	-f - заменять файл, если он уже существует;
	-i - спрашивать, нужно ли заменять существующие файлы;
	-n - не заменять существующие файлы;
	-u - заменять файл только если он был изменен;
	-v - вывести список обработанных файлов;
	Чтобы переименовать файл linux достаточно вызвать утилиту без дополнительных опций. Просто передав ей имя нужного файла и новое имя:

	 $ mv file newfile

9. RM
Удаляет файлы и папки. Очень полезная команда Linux: с её помощью вы можете убрать весь беспорядок. Если нужно рекурсивное удаление, используйте опцию -r. Однако будьте осторожны: конечно, для того чтобы повредить систему вам нужно будет серьёзно постараться, однако можно удалить собственные важные файлы. Rm удаляет файлы не в корзину, из которой потом всё можно будет восстановить, а полностью стирает. Действия оператора rm необратимы. Поверьте, ваши оправдания в духе "rm съела мою курсовую" никому не будут интересны. 
	Чтобы удалить файл linux достаточно передать в параметрах команде адрес файла в файловой системе:

	 $ rm /home/user/file

	Чтобы удалить все файлы, начинающиеся на слово file можно использовать специальный символ *, означает любой символ в любом количестве:

	 $ rm /home/user/file*

	Эта команда удаления файла в linux должна использоваться очень осторожно, чтобы не удалить ничего лишнего. В утилите есть опция -i, которая заставляет программу спрашивать пользователя перед тем, как удалить файл linux:

	 $ rm /home/user/file*

	$ rm: удалить пустой обычный файл «/home/user/file»?

	Если файлов очень много, вы уверены в правильности команды и отвечать каждый раз y неудобно, есть противоположная опция - f. Будут удалены все файлы без вопросов:
	$ rm -f /home/user/file*

	Для удаления директорий, вместе с файлами и поддиректориями используется опция -R, например:

	 $ rm -Rf /home/user/dir

	Будет удалено все что находиться в папке dir, и эта папка. Только будьте бдительны, чтобы не получился знаменитый патч Бармина:

	 $ rm -Rf /*

	Не стоит выполнять эту команду в своей системе, как видите, она удаляет все файлы в файловой системе Linux.

	Удаление файла в linux также возможно с помощью утилиты find. Общий синтаксис find:

	 find папка критерий действие
	 Например, мы хотим удалить файл linux по имени:

	$ find . -type f -name "file" -exec rm -f {} \;

	Будут найдены все файлы с именем file в текущей папке и для них вызвана команда rm -f. Можно не вызывать стороннюю утилиту, а использовать действие delete:

	$ find . -type f -name "file" -delete

	Удалить все файлы в текущей директории, соответствующие определенному регулярному выражению:

	$ find . -regex '\./[a-f0-9\-]\.bak' - delete

	Или удалить файлы старше определенного строка, может быть полезно для удаления старых логов:

	$ find /path/to/files* -mtime +5 -exec rm {} \;
	 Будет выполнено удаление файлов через терминал все файлы в папке старше 5-ти дней.

	Чтобы полностью стереть файл, без возможности восстановления используйте команду shred. Во время удаления файлов с помощью утилиты rm удаляется только ссылка на файл, само же содержимой файла по-прежнему находиться на диске, пока система не перезапишет его новыми данными, а пока этого не случится файл можно легко восстановить. Принцип действия утилиты такой - после удаления файла, его место на диске несколько раз перезаписывается.

	$ shred /home/user/file

	Опцией -n - можно указать количество перезаписей диска, по умолчанию используется 3. А если указать опцию -z программа при последней перезаписи запишет все нулями чтобы скрыть, уничтожение файла.

 10. LN
Создает жёсткие или символические ссылки на файлы. Символические или программные ссылки - это что-то похожее на ярлыки в Windows. Они предоставляют удобный способ доступа к определённому файлу. Символические ссылки указывают на файл, но не имеют никаких метаданных. Жёсткие ссылки, в отличие от символических, указывают на физический адрес области диска, где хранятся данные файла.
	$ ln опции файл_источник файл_ссылки

	Рассмотрим опции утилиты:

	-d - разрешить создавать жесткие ссылки для директорий суперпользователю;
	-f - удалять существующие ссылки;
	-i - спрашивать нужно ли удалять существующие ссылки;
	-P - создать жесткую ссылку;
	-r - создать символическую ссылку с относительным путем к файлу;
	-s - создать символическую ссылку.

11. CHMOD
Изменяет права доступа к файлу. Это чтение, запись и выполнение. Каждый пользователь может изменять права для своих файлов.

	Эта команда имеет типичный для команд linux синтаксис, сначала команда, затем опции, а в конце файл или папка, к которой ее нужно применить:

	$ chmod опции права /путь/к/файлу

	Сначала рассмотрим какими бывают права доступа linux и как они устанавливаются. Пред этим рекомендую прочитать статью про права, ссылка на которую есть выше. Есть три основных вида прав:

	r - чтение;
	w - запись;
	x - выполнение;
	s - выполнение  от имени суперпользователя (дополнительный);
	Также есть три категории пользователей, для которых вы можете установить эти права на файл linux:

	u - владелец файла;
	g - группа файла;
	o - все остальные пользователи;
	Синтаксис настройки прав такой:

	$ группа_пользователейдействиевид_прав

	В качестве действий могут использоваться знаки "+" - включить или "-" - отключить. Рассмотрим несколько примеров:

	u+x - разрешить выполнение для владельца;
	ugo+x - разрешить выполнение для всех;
	ug+w - разрешить запись для владельца и группы;
	o-x - запретить выполнение для остальных пользователей;
	ugo+rwx - разрешить все для всех;
	Но права можно записывать не только таким способом. Есть еще восьмеричный формат записи, он более сложен для понимания, но пишется короче и проще. Я не буду рассказывать как считать эти цифры, просто запомните какая цифра за что отвечает, так проще:

	0 - никаких прав;
	1 - только выполнение;
	2 - только запись;
	3 - выполнение и запись;
	4 -  только чтение;
	5 - чтение и выполнение;
	6 - чтение и запись;
	7 - чтение запись и выполнение.
	Права на папку linux такие же, как и для файла. Во время установки прав сначала укажите цифру прав для владельца, затем для группы, а потом для остальных. Например, :

	744 - разрешить все для владельца, а остальным только чтение;
	755 - все для владельца, остальным только чтение и выполнение;
	764 - все для владельца, чтение и запись для группы, и только чтение для остальных;
	777 - всем разрешено все.
	Каждая из цифр не зависит от предыдущих, вы вбираете именно то, что вам нужно. Теперь давайте рассмотрим несколько опций команды, которые нам понадобятся во время работы:

	-c - выводить информацию обо всех изменениях;
	-f - не выводить сообщения об ошибках;
	-v - выводить максимум информации;
	--preserve-root - не выполнять рекурсивные операции для корня "/";
	--reference - взять маску прав из указанного файла;
	-R - включить поддержку рекурсии;
	--version - вывести версию утилиты;
	Теперь, когда вы знаете опции и как настраиваются права доступа chmod, давайте рассмотрим несколько примеров как работает команда chmod linux.

12. CHOWN
Изменяет владельца файла. Только суперпользователь может изменять владельцев. Для рекурсивного изменения используйте опцию -R.
	$ chown пользователь опции /путь/к/файлу

	В поле пользователь надо указать пользователя, которому мы хотим передать файл. Также можно указать через двоеточие группу, например, пользователь:группа. Тогда изменится не только пользователь, но и группа. Вот основные опции, которые могут вам понадобиться:

	-c, --changes - подробный вывод всех выполняемых изменений;
	-f, --silent, --quiet - минимум информации, скрыть сообщения об ошибках;
	--dereference - изменять права для файла к которому ведет символическая ссылка вместо самой ссылки (поведение по умолчанию);
	-h, --no-dereference - изменять права символических ссылок и не трогать файлы, к которым они ведут;
	--from - изменять пользователя только для тех файлов, владельцем которых является указанный пользователь и группа;
	-R, --recursive - рекурсивная обработка всех подкаталогов;
	-H - если передана символическая ссылка на директорию - перейти по ней;
	-L - переходить по всем символическим ссылкам на директории;
	-P - не переходить по символическим ссылкам на директории (по умолчанию).

13. FIND
Поиск в файловой системе, файлах и папках. Это очень гибкая и мощная команда Linux не только из-за своих способностей ищейки, но и благодаря возможности выполнять произвольные команды для найденных файлов.

	$ find [папка] [параметры] критерий шаблон [действие]

	Папка - каталог в котором будем искать
	Параметры - дополнительные параметры, например, глубина поиска, и т д
	Критерий - по какому критерию будем искать: имя, дата создания, права, владелец и т д.
	Шаблон - непосредственно значение по которому будем отбирать файлы.

	ОСНОВНЫЕ ПАРАМЕТРЫ КОМАНДЫ FIND
	
	-P - никогда не открывать символические ссылки.
	-L - получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
	-maxdepth - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
	-depth - искать сначала в текущем каталоге, а потом в подкаталогах.
	-mount искать файлы только в этой файловой системе.
	-version - показать версию утилиты find.
	-print - выводить полные имена файлов.
	-type f - искать только файлы.
	-type d - поиск папки в Linux.
	КРИТЕРИИ
	Критериев у команды find в Linux очень много, и мы опять же рассмотрим только основные.

	-name - поиск файлов по имени.
	-perm - поиск файлов в Linux по режиму доступа.
	-user - поиск файлов по владельцу.
	-group - поиск по группе.
	-mtime - поиск по времени модификации файла.
	-atime - поиск файлов по дате последнего чтения.
	-nogroup - поиск файлов, не принадлежащих ни одной группе.
	-nouser - поиск файлов без владельцев.
	-newer - найти файлы новее чем указанный.
	-size - поиск файлов в Linux по их размеру.

14. LOCATE
В отличие от find, команда locate ведёт поиск в базе данных updatedb для шаблонов имён файлов. Эта база данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадёжен, потому что вы не можете быть уверены, что ничего не изменилось с момента последнего снимка.
	$ locate опции шаблон_для_поиска

	Опции:

	-A (--all) — выводит только файлы, соответствующие всем заданным шаблонам.
	-b (--basename) — выводит файл, если его название соответствует шаблону.
	-c (--count) — вместо адресов выводит количество найденных файлов.
	-d (--database) — меняет базу данных для поиска, установленную по умолчанию, на пользовательскую.
	-e (--existing) — поиск файлов, существующих на момент запуска команды.
	-L (--follow) — при применении --existing заставляет команду использовать символические ссылки вместо жёстких. Опция --follow включена по умолчанию.
	-h (--help) — выводит справку.
	-i (--ignore-case) — делает команду нечувствительной к регистру.
	-p (--ignore-spaces) — заставляет команду игнорировать пробелы и знаки пунктуации.
	-t (--transliterate) — игнорирует диакритические знаки.
	-l, -n (--limit) — ограничивает количество файлов в выводе команды.
	-P (--nofollow) — заставляет команду использовать жёсткие ссылки вместо символических.
	-0 (--null) — включает использование NUL в качестве разделителя строк.
	-S (--statistics) — выводит статистику по каждой базе данных вместо поиска файлов.
	-q (--quiet) — запрещает команде выводить сообщения об ошибках до завершения поиска.
	-r (--regexp) — поиск с использованием регулярных выражений.
	-V (--version) — показывает версию установленной в системе утилиты locate.
	-w (--wholename) — выводит файл, если в его названии либо адресе есть символы, соответствующие шаблону.

15. DU
Показывает размер файла или каталога. Самые полезные опций: -h (Human), которая преобразует размеры файлов в легко читаемый формат, -s (Summarize), которая выводит минимум данных, и -d (Depth), устанавливающая глубину рекурсии по каталогам.

16. DF
Анализатор дискового пространства. По умолчанию вывод достаточно подробный: перечислены все файловые системы, их размер, количество использованного и свободного пространства. Для удобства есть опция -h, делающая размеры легко читаемыми.

17. DD
Как сказано в официальном руководстве, это команда терминала для копирования и преобразования файлов. Не очень понятное описание, но это всё, что делает dd. Вы передаёте ей файл-источник, пункт назначения и пару дополнительных опций. Затем она делает копию одного файла в другой. Вы можете задать точный размер данных, которые нужно записать или скопировать. Работает утилита со всеми устройствами. Например, если вы хотите перезаписать жёсткий диск нулями из /dev/zero, можете сделать это. Также она часто используется для создания LiveUSB или гибридных ISO образов.

18 MOUNT / UMOUNT
Это команды консоли Linux для подключения и отключения файловых систем Linux. Можно подключать всё: от USB накопителей, до ISO образов. И только у суперпользователя есть права для этого.

LINUX КОМАНДЫ КОНСОЛИ ДЛЯ РАБОТЫ С ТЕКСТОМ
19. MORE / LESS
Это две простенькие команды терминала для просмотра длинных текстов, которые не вмещаются на одном экране. Представьте себе очень длинный вывод команды. Или вы вызвали cat для просмотра файла, и вашему эмулятору терминала потребовалось несколько секунд, чтобы прокрутить весь текст. Если ваш терминал не поддерживает прокрутки, вы можете сделать это с помощью less. Less новее, чем more и поддерживает больше опций, поэтому использовать more нет причин.
	less:
	Запись команды less в терминале выглядит так:
	$ команда опции файл

	Наиболее популярные опции:

	-a, --search-skip-screen — не осуществлять поиск в тексте, который в данный момент отображен на экране;
	-bn, --buffers=n — задать размер буфера памяти;
	-c, --clear-screen — листать текст, полностью стирая содержимое экрана (построчная прокрутка работать не будет);
	-Dxcolor, --color=xcolor — задать цвет отображаемого текста;
	-E, --QUIT-AT-EOF — выйти, когда утилита достигнет конца файла;
	-e, --quit-at-eof — выйти, когда утилита второй раз достигнет конца файла;
	-F, --quit-if-one-screen — выйти, если содержимое файла помещается на одном экране;
	-f, --force — открыть специальный файл;
	-hn, --max-back-scroll=n — задать максимальное количество строк для прокрутки назад;
	-yn, --max-forw-scroll=n — задать максимальное количество строк для прокрутки вперёд;
	-i, --ignore-case — игнорировать регистр;
	-I, --IGNORE-CASE — игнорировать регистр, даже если паттерн для поиска содержит заглавные буквы;
	-jn, --jump-target=n — указать, в какой строке должна быть выведена искомая информация;
	-J, --status-column — пометить строки, соответствующие результатам поиска;
	-n, --line-numbers — не выводить номера строк;
	-N, --LINE-NUMBERS — вывести номера строк;
	-s, --squeeze-blank-lines — заменить множество идущих подряд пустых строк одной пустой строкой;
	-w, --hilite-unread — выделить первую строку нового фрагмента текста.
	Во время просмотра текста утилитой можно управлять при помощи внутренних команд, набирая их на клавиатуре компьютера. Наиболее часто используемые из них:

	h, H — справка;
	Space, Ctrl+V, f, Ctrl+F — прокрутить текст на один экран вперёд;
	Enter, Return, Ctrl+N, e, Ctrl+E, j, Ctrl+J — прокрутить текст на n строк вперед, по умолчанию n=1;
	y, Ctrl+Y, Ctrl+P, k, Ctrl+K — прокрутить текст на n строк назад, по умолчанию n=1;
	Ctrl+→ — прокрутить текст по горизонтали в конец строки;
	Ctrl+← — прокрутить текст по горизонтали в начало строки;
	:d — удалить текущий файл из списка файлов;
	Ctrl+G, :f — вывести основную информацию о файле;
	q, Q, :q, :Q, ZZ — выход.
	
	more:
	$ more опции файл

	Список опций команды:

	-d — вывод информации в конце страницы о клавишах, использующихся для продолжения работы, завершения её или получения инструкций;
	-l — игнорирование в тексте символа разрыва страницы;
	-f — подсчёт числа логических строк вместо экранных;
	-p — очистка экрана терминала для того, чтобы пользователю не пришлось пользоваться прокруткой перед выводом следующей порции текста;
	-c — устранение потребности в прокрутке (как и -p) — отображение текста, начиная с верха экрана, и стирание при этом предыдущего вывода построчно;
	-s — замена нескольких пустых строк, расположенных подряд, одной пустой строкой;
	-u — удаление подчёркивания;
	-n — отображение n-го количества строк;
	+n — отображение текста, начиная со строки с номером n;
	+/строка — поиск в файле указанной строки и начало вывода текста именно с неё;
	--help — вызов справки;
	-v (--version) — вывод на экран текущей версии утилиты.
	Также у команды more есть собственные горячие клавиши и интерактивные команды:

	h (?) — помощь (вывод информации только об интерактивных командах);
	ПРОБЕЛ — отображение следующей порции текста (по умолчанию количество строк зависит от текущего размера окна терминала);
	z — то же, что и ПРОБЕЛ;
	ENTER — вывод текста построчно (шаг команды — одна строка);
	d (^D) — прокрутка текста на количество строк, соответствующее размеру терминала;
	q (Q) — выход из утилиты;
	s — переход на одну строку вперёд;
	f — переход на одну экранную страницу вперёд;
	b (^B) — переход на одну экранную страницу назад;
	' — возвращение к месту начала поиска;
	= — отображение текущего количества строк;
	/pattern — поиск с использованием регулярных выражений;
	n — поиск слов и фраз, соответствующих последнему использованному регулярному выражению;
	!command (:command) — выполнение команды в субоболочке;
	v — открытие файла в текстовом редакторе, назначенном по умолчанию, а если таковой не найден, использование консольного текстового редактора для открытия файла;
	^L — удаление с экрана всего, кроме содержимого файла;
	:n — переход к следующему файлу;
	:p — переход к предыдущему файлу;
	:f — вывод названия текущего файла и количества строк в нём;
	. - повторное выполнение предыдущей команды.


20. HEAD / TAIL
Ещё одна пара, но здесь у каждой команды своя область применения. Утилита head выводит несколько первых строк из файла (голова), а tail выдает несколько последних строк (хвост). По умолчанию каждая утилита выводит десять строк. Но это можно изменить с помощью опции -n. Ещё один полезный параметр -f, это сокращение от follow (следовать). Утилита постоянно выводит изменения в файле на экран. Например, если вы хотите следить за лог файлом, вместо того, чтобы постоянно открывать и закрывать его, используйте команду tail -nf.
	head:
	$ head опции файл

	Здесь:

	Опции — это параметр, который позволяет настраивать работу команды таким образом, чтобы результат соответствовал конкретным потребностям пользователя.
	Файл — это имя документа (или имена документов, если их несколько). Если это значение не задано либо вместо него стоит знак «-», команда будет брать данные из стандартного вывода.
	Чаще всего к команде head применяются такие опции:

	-c (--bytes) — позволяет задавать количество текста не в строках, а в байтах. При записи в виде --bytes=[-]NUM выводит на экран все содержимое файла, кроме NUM байт, расположенных в конце документа.
	-n (--lines) — показывает заданное количество строк вместо 10, которые выводятся по умолчанию. Если записать эту опцию в виде --lines=[-]NUM, будет показан весь текст кроме последних NUM строк.
	-q (--quiet, --silent) — выводит только текст, не добавляя к нему название файла.
	-v (--verbose) — перед текстом выводит название файла.
	-z (--zero-terminated) — символы перехода на новую строку заменяет символами завершения строк.
	
	tail:
	$ tail опции файл

	По умолчанию утилита выводит десять последних строк из файла, но ее поведение можно настроить с помощью опций:

	-c - выводить указанное количество байт с конца файла;
	-f - обновлять информацию по мере появления новых строк в файле;
	-n - выводить указанное количество строк из конца файла;
	--pid - используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
	-q - не выводить имена файлов;
	--retry - повторять попытки открыть файл, если он недоступен;
	-v - выводить подробную информацию о файле;
	В качестве значения параметра -c можно использовать число с приставкой b, kB, K, MB, M, GB, G T, P, E, Z, Y. Еще есть одно замечание по поводу имен файлов. 

21. GREP
Grep, как и другие инструменты Linux, делает одно действие, но делает его хорошо: она ищет текст по шаблону. По умолчанию она принимает стандартный ввод, но вы можете искать в файлах. Шаблон может быть строкой или регулярным выражением. Она может вывести как совпадающие, так и не совпадающие строки и их контекст. Каждый раз, когда вы выполняете команду, которая выдает очень много информации, не нужно анализировать всё вручную - пусть grep делает свою магию.
	$ grep [опции] шаблон [имя файла...]

	Или:

	$ команда | grep [опции] шаблон

	Опции - это дополнительные параметры, с помощью которых указываются различные настройки поиска и вывода, например количество строк или режим инверсии.
	Шаблон - это любая строка или регулярное выражение, по которому будет вестись поиск
	Файл и команда - это то место, где будет вестись поиск. Как вы увидите дальше, grep позволяет искать в нескольких файлах и даже в каталоге, используя рекурсивный режим.
	Возможность фильтровать стандартный вывод пригодится,например, когда нужно выбрать только ошибки из логов или найти PID процесса в многочисленном отчёте утилиты ps.

	ОПЦИИ
	Давайте рассмотрим самые основные опции утилиты, которые помогут более эффективно выполнять поиск текста в файлах grep:

	-b - показывать номер блока перед строкой;
	-c - подсчитать количество вхождений шаблона;
	-h - не выводить имя файла в результатах поиска внутри файлов Linux;
	-i - не учитывать регистр;
	- l - отобразить только имена файлов, в которых найден шаблон;
	-n - показывать номер строки в файле;
	-s - не показывать сообщения об ошибках;
	-v - инвертировать поиск, выдавать все строки кроме тех, что содержат шаблон;
	-w - искать шаблон как слово, окружённое пробелами;
	-e - использовать регулярные выражения при поиске;
	-An - показать вхождение и n строк до него;
	-Bn - показать вхождение и n строк после него;
	-Cn - показать n строк до и после вхождения;
	Все самые основные опции рассмотрели и даже больше, теперь перейдём к примерам работы команды grep Linux.

22. SORT
Сортировка строк текста по различным критериям. Наиболее полезные опции: -n (Numeric), по числовому значению, и -r (Reverse), которая переворачивает вывод. Это может быть полезно для сортировки вывода du. Например, если хотите отсортировать файлы по размеру, просто соедините эти команды.
	$ sort опции файл

	Или

	$ команда | sort опции

	ОПЦИИ
	Теперь рассмотрим основные опции утилиты sort.

	-b - не учитывать пробелы
	-d - использовать для сортировки только буквы и цифры
	-i - сортировать только по ASCII символах
	-n - сортировка строк linux по числовому значению
	-r - сортировать в обратном порядке
	-с - проверить был ли отсортирован файл
	-o - вывести результат в файл
	-u - игнорировать повторяющиеся строки
	-m - объединение ранее отсортированных файлов
	-k - указать поле по которому нужно сортировать строки, если не задано, сортировка выполняется по всей строке.
	-f - использовать в качестве разделителя полей ваш символ вместо пробела.

23. WC
Утилита командной строки Linux для подсчёта количества слов, строк, байт и символов. 
	СИНТАКСИС КОМАНДЫ WC
	Для запуска утилиты откройте терминал и введите:

	$ wc

	Терминал будет ожидать ввода данных. После нажатия комбинации клавиш Ctrl + D командный интерпретатор завершит работу программы и выведет три числа, обозначающих количество строк, слов и байт введённой информации.

	Утилита может обрабатывать файлы. Стандартная инструкция выглядит так:

	$ wc file

	wc — имя утилиты;
	file — название обрабатываемого файла.
	Программа также может принимать параметры для анализа отдельных значений. Наиболее используемые из них приведены в таблице ниже:

	Параметр	Длинный вариант	Значение
	-c	--bytes	Отобразить размер объекта в байтах
	-m	--count	Показать количесто символов в объекте
	-l	--lines	Вывести количество строк в объекте
	-w	--words	Отобразить количество слов в объекте

24. DIFF
Показывает различия между двумя файлами в построчном сравнении. Причём выводятся только строки, в которых обнаружены отличия. Измененные строки отмечаются символом "с", удалнные - "d", а новые - "а". 
	$ diff опции файл1 файл2

	Можно передать больше двух файлов, если это нужно. Перед тем как перейти к примерам, давайте рассмотрим опции утилиты:

	-q - выводить только отличия файлов;
	-s - выводить только совпадающие части;
	-с - выводить нужное количество строк после совпадений;
	-u - выводить только нужное количество строк после отличий;
	-y - выводить в две колонки;
	-e - вывод в формате ed скрипта;
	-n - вывод в формате RCS;
	-a - сравнивать файлы как текстовые, даже если они не текстовые;
	-t - заменить табуляции на пробелы в выводе;
	-l - разделить на страницы и добавить поддержку листания;
	-r - рекурсивное сравнение папок;
	-i - игнорировать регистр;
	-E - игнорировать изменения в табуляциях;
	-Z - не учитывать пробелы в конце строки;
	-b - не учитывать пробелы;
	-B - не учитывать пустые строки.
	Это были основные опции утилиты, теперь давайте рассмотрим как сравнить файлы Linux. В выводе утилиты кроме, непосредственно, отображения изменений, выводит строку в которой указывается в какой строчке и что было сделано. Для этого используются такие символы:

	a - добавлена;
	d - удалена;
	c - изменена.
	К тому же, линии, которые отличаются, будут обозначаться символом <, а те, которые совпадают - символом >.

КОМАНДЫ LINUX ДЛЯ УПРАВЛЕНИЯ ПРОЦЕССАМИ
25. KILL / XKILL / PKILL / KILLALL
Служат для завершения процессов. Но они принимают различные параметры для идентификации процессов. Kill нужен PID процесса, xkill - достаточно кликнуть по окну, чтобы закрыть его, killall и pkill принимают имя процесса. Используйте ту, которая удобна в определенной ситуации.
	
26. PS / PGREP
Как уже говорилось, чтобы уничтожить процесс, нужен его идентификатор. Один из способов получить его, это утилита ps, которая печатает информацию о запущенных процессах. По умолчанию вывод очень длинный, поэтому используйте опцию -e, чтобы увидеть информацию об определённом процессе. Это только снимок состояния на момент вызова, и информация не будет обновляться. Команда ps с ключом aux выводит полную информацию о процессах. Pgrep работает следующим образом: вы задаете имя процесса, а утилита показывает его идентификатор. 
	$ ps опции

	$ ps опции | grep параметр

	Во втором варианте мы используем утилиту grep для того, чтобы отобрать нужные нам процессы по определенному критерию. Теперь рассмотрим опции утилиты. Они делятся на два типа - те, которые идут с дефисом Unix и те, которые используются без дефиса - BSD. Лучше пользоваться только опциями Unix, но мы рассмотрим и одни и другие. Заметьте, что при использовании опций BSD, вывод утилиты будет организован в BSD стиле.

	-A, -e, (a) - выбрать все процессы;
	-a - выбрать все процессы, кроме фоновых;
	-d, (g) - выбрать все процессы, даже фоновые, кроме процессов сессий;
	-N - выбрать все процессы кроме указанных;
	-С - выбирать процессы по имени команды;
	-G - выбрать процессы по ID группы;
	-p, (p) - выбрать процессы PID;
	--ppid - выбрать процессы по PID родительского процесса;
	-s - выбрать процессы по ID сессии;
	-t, (t) - выбрать процессы по tty;
	-u, (U) - выбрать процессы пользователя.
	Опции форматирования:

	-с - отображать информацию планировщика;
	-f - вывести максимум доступных данных, например, количество потоков;
	-F - аналогично -f, только выводит ещё больше данных;
	-l - длинный формат вывода;
	-j, (j) - вывести процессы в стиле Jobs, минимум информации;
	-M, (Z) - добавить информацию о безопасности;
	-o, (o) - позволяет определить свой формат вывода;
	--sort, (k) - выполнять сортировку по указанной колонке;
	-L, (H)- отображать потоки процессов в колонках LWP и NLWP;
	-m, (m) - вывести потоки после процесса;
	-V, (V) - вывести информацию о версии;
	-H - отображать дерево процессов;

27. TOP / HTOP
Обе команды похожи, обе отображают процессы и могут быть использованы как консольные системные мониторы. Я рекомендую установить htop, если в вашем дистрибутиве он не поставляется по умолчанию, так как это улучшенная версия top. Вы сможете не только просматривать, но и контролировать процессы через его интерактивный интерфейс.

28. TIME
Время выполнения процесса. Это секундомер для выполнения программы. Полезно, если вам интересно, насколько сильно ваша реализация алгоритма отстает от стандартной. Но, несмотря на такое название, она не сообщит вам текущее время, используйте для этого команду date.

КОМАНДЫ LINUX ОКРУЖЕНИЯ ПОЛЬЗОВАТЕЛЯ
29. SU / SUDO
Su и sudo - это два способа выполнить одну и ту же задачу: запустить программу от имени другого пользователя. В зависимости от вашего дистрибутива вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет наиболее безопасным вариантом работы. 
	$ su опции пользователь

	Вот ее основные опции:

	-c, --command - выполнить команду
	-g, --group - установить основную группу пользователя (только для root)
	-G --supp-group - дополнительные группы пользователя (только для root)
	-, -l, --login - режим входа, будут очищены и инициализированы с учетом нового пользователя все переменные окружения, а также изменен домашний каталог
	-p, --preserve-environment - сохранить переменные окружения
	-s, --shell - задать оболочку для входа
	--version - отобразить версию программы.

30. DATE
В отличие от time, делает именно то, чего вы от неё и ожидаете: выводит дату и время в стандартный вывод. Его можно форматировать в зависимости от ваших потребностей: вывести год, месяц, день, установить 12-ти или 24-ти часовой формат, получить наносекунды или номер недели. Например, date +"%j %V", выведет день в году и номер недели в формате ISO.

31. ALIAS
Команда создаёт синонимы для других команд Linux. То есть вы можете делать новые команды или группы команд, а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или создания более понятных имен для команд, которые вы используете нечасто и не можете запомнить.
	Чтобы посмотреть какие псевдонимы linux команд уже заданны в вашей системе просто выполните:

	 $ alias

	Команда покажет все alias команд linux определенные для текущего пользователя. Вывод очень сильно зависит от вашего дистрибутива. Общий синтаксис команды выглядит следующим образом:

	$ alias имя="значение"

	$ alias имя="команда аргумент1 аргумент2"

	$ alias имя="/путь/к/исполняемому/файлу"

	Вы можете создавать новые псевдонимы, просто выполняя эту команду в терминале. Но созданные таким образом алиасы linux будут работать только в этом терминале и только до его закрытия.

	Давайте для примера создадим alias linux для такой часто используемой команды, как clear (очистить вывод терминала):

	$ alias c='clear'

	Теперь, чтобы очистить терминал достаточно выполнить:

	$ с

	Удалить созданный alias можно с помощью команды unalias:

	$ unalias c

	Но как я уже сказал, такие alias команд linux сохраняются только до закрытия терминала. Поэтому их необходимо создавать в начале каждой терминальной сессии. Для этого можно записать все нужные команды в ~/.bashrc. При запуске терминала, каждый раз выполняется этот скрипт, чтобы установить переменные окружения и подготовить оболочку. Таким образом добавив нужные строки в конец файла мы получим работающие alias linux в каждом терминале.

	Продолжим создание alias для команды clear:

	$ vi ~/.bashrc

	Добавьте эту строку в конец файла:

	$ alias c='clear'

	Затем сохраните и закройте редактор (:wq). Чтобы проверить работоспособность запустите новый терминал. Если вы хотите чтобы ваши алиасы linux были доступны для всех пользователей, необходимо использовать файл /etc/bashrc.

	Поскольку .bashrc, это обычный bash скрипт, перед нами открываются большие возможности. Например мы можем добавить alias команд с использованием sudo, если текущий пользователь не root:

	$ if [ $UID -ne 0 ]; then
	$ alias reboot='sudo reboot'
	$ alias update='sudo apt-get upgrade'
	$ fi

	Ещё мы можем менять команды алиасов в зависимости от дистрибутива:

	$ _myos="$(uname)"
	$ case $_myos in
	$ Linux) alias foo='/path/to/linux/bin/foo';;
	$ FreeBSD|OpenBSD) alias foo='/path/to/bsd/bin/foo' ;;
	$ SunOS) alias foo='/path/to/sunos/bin/foo' ;;
	$ *) ;;
	$ esac

	Чтобы удалить alias достаточно просто удалить запись о нем, из того файла в который вы её добавили. Мы рассмотрели основы добавления alias linux, теперь давайте перейдем к списку полезных алиасов linux.

	ПОЛЕЗНЫЕ ALIAS LINUX
	Вы можете добавить в своей системе любые или даже все эти алиасы linux чтобы повысить продуктивность своей работы в терминале.

	1. ВЫВОД LS
	Цветной вывод:

	$ alias ls='ls --color=auto'

	Показывать скрытые файлы и представлять вывод в виде списка:

	$ alias ll='ls -la'

	Показать только скрытые файлы:

	$ alias l.='ls -d .* --color=auto'

	2. ПЕРЕМЕЩЕНИЕ ПО КАТАЛОГАМ
	Исправляем опечатку:

	$ alias cd..='cd ..'

	Быстрое перемещение от текущей директории:

	$ alias ..='cd ..'
	$ alias ...='cd ../../../'
	$ alias ....='cd ../../../../'
	$ alias .....='cd ../../../../'
	$ alias .4='cd ../../../../'
	$ alias .5='cd ../../../../..'

	3. ВЫВОД GREP
	Делаем вывод цветным:

	$ alias grep='grep --color=auto'
	$ alias egrep='egrep --color=auto'
	$ alias fgrep='fgrep --color=auto'

	4. КАЛЬКУЛЯТОР
	Запускать калькулятор с поддержкой стандартной библиотеки mathlib:

	$ alias bc='bc -l'

	5. СОЗДАНИЕ КАТАЛОГОВ

 
	Создавать дерево каталогов, если оно не существует:

	$ alias mkdir='mkdir -pv'

	6. ВЫВОД DIFF
	Делаем вывод diff цветным:

	$ alias diff='colordiff'

	7. ВЫВОД MOUNT
	Сделаем вывод mount читаемым:

	$ alias mount='mount | column -t'

	8. ИСТОРИЯ
	Сократим команды для экономии времени:

	$ alias h='history'
	$ alias j='jobs -l'

	9. ИНФОРМАЦИЯ И ДАТА
	$ alias path='echo -e ${PATH//:/\\n}'
	$ alias now='date +"%T"'
	$ alias nowtime=now
	$ alias nowdate='date +"%d-%m-%Y"'

	10. РЕДАКТОР VIM
	$ alias команд linux для использования редактора vim по умолчанию:

	$ alias vi=vim
	$ alias svi='sudo vi'
	$ alias vis='vim "+set si"'
	$ alias edit='vim'

	11. PING
	Посылать только пять запросов:

	$ alias ping='ping -c 5'

	Интервал между запросами одна секунда:

	$ alias fastping='ping -c 100 -s.2'

	12. ОТКРЫТЫЕ ПОРТЫ
	$ alias ports='netstat -tulanp'

	13. WAKEUP
	Будим серверы в режиме сна по mac адресу с помощью утилиты wakeonlan:

	$ alias wakeupnas01='/usr/bin/wakeonlan 00:11:32:11:15:FC'
	$ alias wakeupnas02='/usr/bin/wakeonlan 00:11:32:11:15:FD'
	$ alias wakeupnas03='/usr/bin/wakeonlan 00:11:32:11:15:FE'

	14. УПРАВЛЕНИЕ IPTABLES
	$ alias iptlist='sudo /sbin/iptables -L -n -v --line-numbers'
	$ alias iptlistin='sudo /sbin/iptables -L INPUT -n -v --line-numbers'
	$ alias iptlistout='sudo /sbin/iptables -L OUTPUT -n -v --line-numbers'
	$ alias iptlistfw='sudo /sbin/iptables -L FORWARD -n -v --line-numbers'
	$ alias firewall=iptlist

	15. УТИЛИТА CURL
	Получить заголовки сервера:

	$ alias header='curl -I'

	Проверять поддержку сжатия на сервере:

	$ alias headerc='curl -I --compress'

	16. РАБОТА С ФАЙЛАМИ
	Не удалять корень и предупреждать об удалении файлов:

	$ alias rm='rm -I --preserve-root'

	Предупреждения:

	$ alias mv='mv -i'
	$ alias cp='cp -i'
	$ alias ln='ln -i'

	Защита от изменения прав для /:

	$ alias chown='chown --preserve-root'
	$ alias chmod='chmod --preserve-root'
	$ alias chgrp='chgrp --preserve-root'

	17. ОБНОВЛЕНИЕ DEBIAN
	Установка пакета:

	$ alias apt="sudo apt"
	$ alias updatey="sudo apt --yes"

	Обновление одной командой:

	$ alias update='sudo apt update && sudo apt upgrade'

	18. ОБНОВЛЕНИЕ REDHAT
	В семействе дистрибутивов Red Hat используется пакетный менеджер yum:

	$ alias update='yum update'
	$ alias updatey='yum -y update'

	19. СТАТЬ СУПЕРПОЛЬЗОВАТЕЛЕМ
	$ alias root='sudo -i'
	$ alias su='sudo -i'

	20. ВЫКЛЮЧЕНИЕ
	Выполнять команды выключения через sudo:

	$ alias reboot='sudo /sbin/reboot'
	$ alias poweroff='sudo /sbin/poweroff'
	$ alias halt='sudo /sbin/halt'
	$ alias shutdown='sudo /sbin/shutdown'

	21. УПРАВЛЕНИЕ СЕРВЕРАМИ
	$ alias nginxreload='sudo /usr/bin/nginx -s reload'
	$ alias nginxtest='sudo /usr/bin/nginx -t'
	$ alias lightyload='sudo systemctl reload lighttpd'
	$ alias lightytest='sudo /usr/sbin/lighttpd -f /etc/lighttpd/lighttpd.conf -t'
	$ alias httpdreload='sudo /usr/sbin/apachectl -k graceful'
	$ alias httpdtest='sudo /usr/sbin/apachectl -t && /usr/sbin/apachectl -t -D DUMP_VHOSTS'

	22. МУЛЬТИМЕДИА
	Открыть видео в текущей директории:

	$ alias playavi='mplayer *.avi'
	$ alias vlc='vlc *.avi'

	Добавить в плейлист музыку из текущей директории:

	$ alias playwave='for i in *.wav; do mplayer "$i"; done'
	$ alias playogg='for i in *.ogg; do mplayer "$i"; done'
	$ alias playmp3='for i in *.mp3; do mplayer "$i"; done'

	Открыть музыку из устройства nas:

	$ alias nplaywave='for i in /nas/multimedia/wave/*.wav; do mplayer "$i"; done'
	$ alias nplayogg='for i in /nas/multimedia/ogg/*.ogg; do mplayer "$i"; done'
	$ alias nplaymp3='for i in /nas/multimedia/mp3/*.mp3; do mplayer "$i"; done'

	22. СИСТЕМНОЕ АДМИНИСТРИРОВАНИЕ
	Работать с интерфейсом eth1:

	$ alias dnstop='dnstop -l 5 eth1'
	$ alias vnstat='vnstat -i eth1'
	$ alias iftop='iftop -i eth1'
	$ alias tcpdump='tcpdump -i eth1'
	$ alias ethtool='ethtool eth1'

	Работать с интерфейсом wlan0 по умолчанию:

	$ alias iwconfig='iwconfig wlan0'

	23. ИНФОРМАЦИЯ О СИСТЕМЕ
	Использование памяти:

	$ alias meminfo='free -m -l -t'

	Показать процессы потребляющие больше всего памяти:

	$ alias psmem='ps auxf | sort -nr -k 4'
	$ alias psmem10='ps auxf | sort -nr -k 4 | head -10'

	Показать процессы использующие процессор:

	$ alias pscpu='ps auxf | sort -nr -k 3'
	$ alias pscpu10='ps auxf | sort -nr -k 3 | head -10'

	Информация о процессоре:

	$ alias cpuinfo='lscpu'

	Посмотреть память видеокарты:

	$ alias gpumeminfo='grep -i --color memory /var/log/Xorg.0.log'

	25. УТИЛИТА WGET
	Продолжать незавершенную загрузку по умолчанию:

	$ alias wget='wget -c'

	26. БРАУЗЕРЫ
	Сокращения:

	$ alias ff='/usr/bin/firefox'
	$ alias chrome='/usr/bin/google-chrome'
	$ alias opera='/usr/bin/opera'
	$ alias chromium='/usr/bin/chromium'

	Браузер по умолчанию:

	$ alias browser=chrome

	27. ПРАВИЛЬНЫЕ ЕДИНИЦЫ ИЗМЕРЕНИЯ
	Правильное отображение данных для free, df и du:
	$ alias df='df -H'
	$ alias du='du -ch'
	$ alias free='free -h'

32. UNAME
Выводит некую основную информацию о системе. Без параметров она не покажет ничего полезного, кроме строчки Linux, но, если задать параметр -a (All), можно получить информацию о ядре, имени хоста и узнать архитектуру процессора.
	Самый распространенный способ посмотреть ядро linux - это команда uname.
 	$ uname -a
 	
 	Eсли же вам не нужна вся эта информация, то можно просто посмотреть версию ядра с помощью опции -r:

 	$ uname -r 
 	
 	Мы можем посмотреть строку запуска Grub с помощью команды:

 	$ cat /proc/cmdline
 	
 	Тут в параметре BOOT_IMAGE мы можем видеть полный путь к образу ядра, который был сейчас загружен. В той же файловой системе /proc есть файл version, где хранится версия ядра:

 	$ cat /proc/version
 	
 	Дальше, чтобы получить ту же информацию мы можем посмотреть лог dmesg, в самом начале отображается версия ядра, которая будет загружена:

 	$ dmesg | grep Linux
 	
 	Также, вы можете узнать какие версии ядра установлены в вашей системе с помощью пакетного менеджера, но это вам никак не поможет понять какая версия сейчас запущена, если установлено несколько вариантов. В Ubuntu для этого есть утилита dpkg:

 	$ sudo dpkg -l | grep linux-headers | grep ii | awk '{print $3}' 
 	
 	А в Red Hat / CentOS можно воспользоваться аналогичной программой - rpm:

	 $ sudo rpm -q kernel

	Также в ответ на вопрос как посмотреть ядро Linux можно посоветовать посмотреть содержимое папки /boot на предмет образов ядра с именем vmlinuz:

	 $ ls /boot | grep vmlinuz

33. UPTIME
Сообщает вам время работы системы. Не очень существенная информация, но может быть полезна для случайных вычислений или просто ради интереса, чтобы узнать, как давно был перезагружен сервер.

34. SLEEP
Вам, наверное, интересно как же её можно использовать. Даже не учитывая Bash-скриптинг, у неё есть свои преимущества. Например, если вы хотите выключить компьютер через определенный промежуток времени или использовать в качестве импровизированной тревоги.

КОМАНДЫ LINUX ДЛЯ УПРАВЛЕНИЯ ПОЛЬЗОВАТЕЛЯМИ
35. USERADD / USERDEL / USERMOD
Эти команды консоли Linux позволяют вам добавлять, удалять и изменять учетные записи пользователей. Скорее всего, вы не будете использовать их очень часто. Особенно если это домашний компьютер, и вы являетесь единственным пользователем. Управлять пользователями можно и с помощью графического интерфейса, но лучше знать об этих командах на всякий случай.

36. PASSWD
Эта команда позволяет изменить пароль учетной записи пользователя. Как суперпользователь вы можете сбросить пароли всех пользователей, даже несмотря на то, что не можете их увидеть. Хорошая практика безопасности - менять пароль почаще.

LINUX КОМАНДЫ ДЛЯ ПРОСМОТРА ДОКУМЕНТАЦИИ
37. MAN / WHATIS
Команда man открывает руководство по определённой команде. Для всех основных команд Linux есть man страницы. Whatis показывает, какие разделы руководств есть для данной команды.

38. WHEREIS
Показывает полный путь к исполняемому файлу программы. Также может показать путь к исходникам, если они есть в системе.

КОМАНДЫ LINUX ДЛЯ УПРАВЛЕНИЯ СЕТЬЮ
39. IP
Если список команд Linux для управления сетью вам кажется слишком коротким, скорее всего вы не знакомы с утилитой ip. В пакете net-tools содержится множество других утилит: ipconfig, netstat и прочие устаревшие, вроде iproute2. Всё это заменяет одна утилита - ip. Вы можете рассматривать её как швейцарский армейский нож для работы с сетью или как непонятную массу, но в любом случае за ней будущее. Просто смиритесь с этим.

	$ ip [опции] объект команда [параметры]

	Опции - это глобальные настройки, которые сказываются на работе всей утилиты независимо от других аргументов, их указывать необязательно.

	объект - это тип данных, с которым надо будет работать, например: адреса, устройства, таблица arp, таблица маршрутизации и так далее;
	команды - какое-либо действие с объектом;
	параметры - само собой, командам иногда нужно передавать параметры, они передаются в этом пункте.
	Дальше рассмотрим все еще более подробно:

	-v, -Version - только вывод информации об утилите и ее версии.
	-h, -human - выводить данные в удобном для человека виде.
	-s, -stats - включает вывод статистической информации.
	-d, -details - показывать ещё больше подробностей.
	-f, -family - позволяет указать протокол, с которым нужно работать, если протокол не указан, то берется на основе параметров команды. Опция должна принимать одно из значений: bridge, dnet, inet, inet6, ipx или link. По умолчанию используется inet, link - означает отсутствие протокола.
	-o, -oneline - выводить каждую запись с новой строки.
	-r,-resolve - определять имена хостов с помощью DNS.
	-a, -all - применить команду ко всем объектам.
	-c, -color - позволяет настроить цветной, доступные значения: auto, always и never.
	-br, -brief - выводить только базовую информацию для удобства чтения.
	-4 - короткая запись для -f inet.
	-6 - короткая запись для -f inet-f inet6.
	-B - короткая запись для -f inet-f bridge.
	-0 - короткая запись для -f inet -f link.
	
	Теперь давайте рассмотрим самые важные объекты.

	- address или a - сетевые адреса.
	- link или l - физическое сетевое устройство.
	- neighbour или neigh - просмотр и управление ARP.
	- route или r - управление маршрутизацией.
	- rule или ru - правила маршрутизации.
	- tunnel или t - настройка туннелирования.

40. PING
Ping - это ICMP ECHO_REQUEST дейтаграммы, но на самом деле это неважно. Важно то, что утилита ping может быть очень полезным диагностическим инструментом. Она поможет быстро проверить, подключены ли вы к маршрутизатору или к интернету, и дает кое-какое представление о качестве этой связи.

	$ ping опции адрес_узла

	Формат команды ping очень прост. В качестве адреса узла можно передавать как ip адрес, так и доменное имя. Опции настраивают поведение утилиты. Рассмотрим основные из них:

	-4 - использовать только ipv4 (по умолчанию);
	-6 - использовать только ipv6;
	-A - адаптивный режим, время между отправками пакета адаптируется к времени передачи и приема пакета, но не меньше чем 200мс;
	-b - разрешить ping широковещательного адреса;
	-с - количество пакетов, которые нужно отправить;
	-D - выводить время в виде UNIX timestamp;
	-f - режим флуда, в этом режиме пакеты передаются без задержек, может использоваться для совершения DoS атак на отдельные узлы. Количество точек, которые выводит утилита обозначает количество потерянных пакетов;
	-i - интервал в секундах между отправкой пакетов;
	-I - использовать этот сетевой интерфейс для отправки пакетов;
	-l - режим перегрузки, отправляется очень много пакетов и система не следит за ответными пакетами;
	-n - не получать домены для ip адресов;
	-r - игнорировать таблицы маршрутизации и отправить пакет на указанный интерфейс;
	-s - размер одного пакета;
	-t - установить TTL вручную;
	-v - более подробный вывод.


41. NETHOGS
Если у вас медленный интернет, то вам, наверное, было бы интересно знать, сколько трафика использует какая-либо программа в Linux или какая программа потребляет всю скорость. Теперь это можно сделать с помощью утилиты nethogs. Для того чтобы задать сетевой интерфейс используйте опцию -i.
 
42. TRACEROUTE
Это усовершенствованная версия ping. Мы можем увидеть не только полный маршрут сетевых пакетов, но и доступность узла, а также время доставки этих пакетов на каждый из узлов.
	$ traceroute опции адрес_узла

	В качестве адреса может использоваться ip адрес или доменное имя. Рассмотрим основные опции:

	-4 или -6 - использовать ipv4 или ipv6 протокол;
	-I - использовать ICMP пакеты вместо UDP;
	-T - использовать TCP пакеты вместо UDP;
	-F - не фрагментировать пакеты;
	-f - указать TTL с которого нужно начать;
	-g - передавать пакет через указанный шлюз;
	-i - передавать пакет через указанный интерфейс;
	-m - максимальное количество узлов, через которые пройдет пакет;
	-q - количество пакетов, отправляемых за раз, по умолчанию три;
	-n - не узнавать доменные имена;
	-p - указать порт вместо порта по умолчанию;
	-w - установить время ожидания ответа от узла, по умолчанию полсекунды;
	-r - использовать другой роутер вместо того, что указанный в таблице маршрутизации;
	-z - минимальный интервал между пакетами;
	-U - использовать UDP с увеличением номера порта;
	-UL - использовать протокол UDPLITE;
	-D - использовать протокол DCCP;
	--mtu - указать размер пакета;
	-P - протокол, доступны такие значения: raw, dccp, udplite, udp, tcpconn, tcp, icmp.

